clear; clc; close all;

% --- 1. SETUP DATA ---
load("../res/dataset.mat")

% --- CONFIGURATION ---
N_blocks = 3;
sx = NOISE_STD_DEV_I; 
sy = NOISE_STD_DEV_V; 
N = floor(length(use_data_soc_meas)/3.0);

% Initialize log
as_log = []; 
bs_log = []; % We need to store intercepts now

colors = ['r', 'g', 'b', '']; % Colors for the blocks

figure;

for block_idx = 1:N_blocks
    fprintf('\n--- Block %d ---\n', block_idx);
    
    % 1. Get Raw Data
    x_raw = use_data_soc_meas( (block_idx-1)*N+1 : block_idx*N );
    y_raw = use_data_r0_meas( (block_idx-1)*N+1 : block_idx*N ); 
    
    % 2. MEAN CENTERING (Crucial Step)
    % We shift the data so its center is at (0,0).
    % This allows your y=ax solver to find the correct rotation (slope).
    mx = mean(x_raw);
    my = mean(y_raw);
    
    x = x_raw - mx;
    y = y_raw - my;

    N_iter = 4; 
    
    % --- 3. INITIALIZATION ---
    si = diag([1/sx 1/sy]);
    W = kron(si, eye(N));
    
    % Initial Guess using centered data
    as = x \ y;     
    xs = x;         
    
    % --- 4. ITERATIVE TLS SOLVER ---
    fprintf('Iter |  Slope (a)  | Residual Norm\n');
    fprintf('-----------------------------------\n');
    
    as_log_block = [];

    for iter = 1:N_iter
        ys = as * xs;
        
        dx = x - xs;       
        dy = y - ys;      
        d = [dx; dy];      
        
        Gx = [eye(N), zeros(N,1)]; 
        Gy = [as*eye(N), xs];       
        G = [Gx; Gy];
        
        WG = W * G;
        Wd = W * d;
        
        xx = WG \ Wd;
        
        xs = xs + xx(1:N);      
        as = as + xx(N+1);  

        % History of a_tls updates
        as_log_block = [as_log_block; as];
        
        res_norm = norm(Wd);
        fprintf('%4d | % .6f | %.4e\n', iter, as, res_norm);
    end
    
    % --- 5. RESULTS RECOVERY ---
    % The slope 'a' is correct.
    % We must calculate 'b' (intercept) to map back to original coordinates.
    % y = a*x + b  =>  mean_y = a*mean_x + b  =>  b = mean_y - a*mean_x
    a_tls = as;
    b_tls = my - a_tls * mx;
    
    as_log = [as_log; a_tls];
    bs_log = [bs_log; b_tls];

    for i = 1:N_iter
        % Reconstruct the index for this block to plot the line segment only where data exists
        idx_range = (block_idx-1)*N+1 : block_idx*N;
        x_seg = use_data_soc_meas(idx_range);
        
        % Calculate y using y = ax + b
        y_fit = as_log_block(i) * x_seg + bs_log(block_idx);
        plot(x_seg, y_fit, [colors(block_idx) '--'], 'LineWidth', 2, 'DisplayName', sprintf('Fit Block %d (a=%.4f)', block_idx, as_log_block(i)));
        hold on;
    end    
    
    fprintf('Final TLS Model: y = %.4fx + %.4f\n', a_tls, b_tls);
end

% --- PLOTTING ---

% Plot all raw data
grid on;

for i = 1:N_blocks
    % Reconstruct the index for this block to plot the line segment only where data exists
    idx_range = (i-1)*N+1 : i*N;
    x_seg = use_data_soc_meas(idx_range);
    
    % Calculate y using y = ax + b
    y_fit = as_log(i) * x_seg + bs_log(i);
    
    plot(x_seg, y_fit, [colors(i)], 'LineWidth', 2, 'DisplayName', sprintf('Final Fit %d (a=%.4f)', i, as_log(i)));  hold on;
end

plot(use_data_soc_meas, use_data_r0_meas, 'ko', 'DisplayName', 'Data', 'MarkerFaceColor', 'k', 'MarkerSize', 3); 

legend show;
title('TLS Fitting with Intercept Correction');
xlabel('SOC'); ylabel('R0');